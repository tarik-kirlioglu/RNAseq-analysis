---
title: "Packages and DESeq2"
author: "Tarık KIRLIOĞLU"
date: "2024-06-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages and DESeq2

R paketleri, R fonkdiyonlarının, kodlarının ve verilerinin koleksiyonudur. `library`dizininde saklanır. Kurulum ile yüklenen paketler mevcuttur. İhtiyaç duyulduğunda ek paketler yüklemek mümkündür. R paketlerinin yer aldığı dizini bulmak için `.libPaths()` fonksiyonu kullanılır. Kurulu tüm paketlerin listesini almak için ise `library()` fonksiyonu kullanılır.

R ortamına yeni paketler eklenmek isteniyorsa birden fazla depodan bu işlem gerçekleştirilebilir. Kullanıcıların ve geliştiricilerin kullandığı depolar mevcuttur. Bunlar çevrimiçi ve erişilebilirdir. Sıklıkla kullanılan depolar;
CRAN (Kapsamlı R Arşiv Ağı),
Biocunductor (Biyoinformatik için özelleşmiş bir depodur) ve 
Github (Açık kaynaklı projelerin yer aldığı popüler depodur.) 

R paketlerini CRAN'dan yüklemek için `install.packages("package_name")` kullanılır.

Bicunductor paketlerini kurmak ve yüklemek için `BiocManager` paketi kullanılır. Bu paket `install.packages("BiocManager")` komutu ile yüklenir. Yükleme tamamlandıktan sonra Biocunductor paketlerini yüklemek için `BiocManager::install("DESeq2")` komutu kullanılır. Eğer hata ile karşılaşılması durumunda Biocunductor web sayfasından indirilmek istenen paket ulaşılarak yükleme için geçerli komut ile yükleme gerçekleştirilebilir.

Github üzerinden bir yükleme yapılmak isteniyorsa;
`install.packages("devtools")` komutu ile devtools yüklenir. Daha sonra yüklenmek istenen paketler;
`devtools::install_github("tidyverse/tidyverse")` komutu kullanılarak yükleme gerçekleştirilebilir.

Bilgisayarınızda hangi paketlerin yüklü olduğunu kontrol etmek için;
`installed.pasckages()` komutu kullanılır.

Bilgisayarınızda var olan tüm paketleri güncellemek için;
`update.packages()` komutu kullanılır.

Belirli bir paketi güncellemek için;
`install.packages("package name")` komutu kullanılır.

## Differantial Gene Expression Analysis with DESeq2

Diferensiyel olarak ifade edilen genlerin analizine geçmeden önce analiz aşamasında kullanılan paketlerin yüklenmesi gerekmektedir. Bu paketleri yukarıda ifade edilen şekilde yüklenebilir. 

Paketler indirildikten sonra çalışılacak paketlerin R ortamına yüklenmesi için ; `library("package_name")` kullanılır.

```{r}
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(RColorBrewer)
library(tidyverse)
library(EnhancedVolcano)
```

Bu işlemden sonra çalışılacak klasöre gitmek için `setwd()` kullanılabilir. Ayrıca `Session`, `Set Working Directory`, `Choose Directory` seçildikten sonra çalışılacak klasör seçilebilir.

```{r}
setwd("C:/Users/Honor/Desktop/deseq")
```


Analizin ilk adımı olarak `counts` dosyasının yüklenmesi gerekir. Counts dosyası RNA-seq veri analizi sonucunda elde edilen sayım matrisidir. Dosya formatı genellikle `.csv` uzantılı kullanılır.

```{r}
counts <- read.csv("counts.csv",
                   row.names = 1,
                   sep = ",",
                   header = T)
head(counts)
```


Bir sonraki adımda `col_data` dosyasının yüklenmesi gerekir.col_data dosyası ise örnekler hakkında bilgiler içermektedir.

```{r}
col_data <- data.frame(condition=c("treated", "treated", "control", "control"))

rownames(col_data) <- colnames(counts)

head(col_data)
```

Sütun isimleri ile sıra isimlerinin aynı olması gerekmektedir. Bunun için sıra isimlerinin sutün isimleri ile eşleşip eşleşmediğini sorabiliriz.

```{r}
all(colnames(counts)==rownames(col_data))
```
Bu işlemden sonra DESeq objesi yani sayım matrislerinin girişini oluşturmak gerekmektedir. Bu `DESeqDataSetFromMatrix()` fonksiyonu ile gerçekleştirilir. Bu objeye `counts` ve `col_data` verilerini girdi olarak sunarız.

```{r}
dds <- DESeqDataSetFromMatrix(countData =counts,
                              colData = col_data,
                              design = ~condition)
dds
```
Bu işlemden sonra filtreleme işlemi gerçekleştirilir. Bunun amacı 10'dan saha az sayım içeren sıraların kaldırılmasını amaçlamaktadır.

```{r}
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
```

Hangi koşula göre karşılaştırma yapmak istediğimizi belirtmemiz gerekir. Bunun için factor level seçimi yapmalıyız. `relevel()` komutu ile seçim yapabiliriz. Eğer seçim yapmazsak R, alfabetik sıralamaya göre referans seçimini gerçekleştirir.

```{r}
dds$condition <- relevel(dds$condition, ref = "control")
```

Artık `DESeq()` fonksiyonunu çalıştırmaya hazırız. Bu fonksiyon ile beraber hesaplamalar gerçekleştirildikten sonra logFC deperleri ve bir dizi istatistiksel değerlere ulaşabiliriz. 

```{r}
dds <- DESeq(dds)
res <- results(dds)
res
```
**Not:** Eğer sistem çökerse bu teknik tekrarı olmamasından dolayı kaynaklanmaktadır. DESeq2 ile analiz yapmak için örneklerin teknik tekrarlarının olması gerekmektedir.

Analiz sonucunda özet bilgi almak için `summary(res)` fonksiyonunu kullanabiliriz.

```{r}
summary(res)

```
pvalue'ye göre sıralama yapmasını isteyebiliriz.

```{r}
resOrdered <- res[order(res$pvalue),]

head(resOrdered)

```

DESeq objesi eğer istenirse dataframe'e çevrilebilir.Bunun için `as.data.frame()` fonksiyonu kullanılır.


```{r}
res_deseq <- as.data.frame(res)
class(res_deseq)

head(res_deseq)
```

Bir takım özel genlerin sorgusu yapılabilir. Örneğin Xist geni üzerine bir tarama gerçekleştirelim. Gene ulaşmak için kapalı parantez kullanılır.

```{r}
res_deseq["Xist",]
```
**Not:** Şunu söyleyebiliriz ki Xist geni kontrole kıyasla aşağı regüle edilmiştir. Yani tedavi altında ifadesinde bir artış söz konusu değildir.

Sayım matrislerinin normalize edilmiş hali elde edilebilir. Bunun için ``counts()` fonksiyonu kullanılır.

```{r}
normalized_counts <- counts(dds, normalized=T)
head(normalized_counts)
```
Elde edilen sonuçlar `.csv` uzantılı bir şekilde kaydedilebilir.Bunun için `write.csv()` fonksiyonu kullanılır.

```{r}
write.csv(res_deseq, "res_deseq.csv")
write.csv(normalized_counts, "normalize_counts.csv")
```

## Görselleştirme

DESeq analizi ile beraber bir çok veri görselleştirmesi yapılabilir. Burada DESeq2 paketinin sunmuş olduğu bir çok fonksiyon kullanılabilir. Aynı zamanda ggplot, pheatmap gibi paketler de kullanılabilir.

### 1)PCA (Principal Component Analysis)
Temel bileşen analizi, DESeq2 paketinin sunmuş olduğu fonksiyonlar ile gerçekleştirilebilir.PCA çok boyutlu veri setlerinin düşük boyuta indirgenmesidir. Bunu, çok büyük veri setlerinin izdüşümü olarak düşünebiliriz.
Öncelikli olarak pca grafiğini oluşturabilmek için variance stabilizing transformation işlemini gerçekleştirmemiz gerekir. Bunu `vst()` fonksiyonu ile yapabiliriz.Daha sonra transforme edilen değerler üzerinden pca grafiği oluşturabiliriz. Sonuç olarak,  benzer koşullar altında olan örneklerin beraber kümelendiğini görmek isteriz. Örneklerin bireysel olarak farklı yerlerde bulunması pek istenen bir durum değildir.

```{r}
vstdata <- vst(dds,
               blind = F)
plotPCA(vstdata,
        intgroup="condition")
```

### 2)MA Grafiği

MA grafiği,log2FC ile normalize edilmiş sayımların ortalamasına ilişkin bir görseldir. Bu görsel ile differensiyal olarak ekspre edilmiş genler hakkında bilgi alabiliriz. Her bir nokta gendir. Mavi ile renklendirilen kısımlar p-value değeri 0.05 ve 0.05'den küçük olan genleri göstermektedir. log2FC pozitif kısımlar up-regule olan genleri temsil ederken log2FC negatif kısımlar ise down-regüle edilen genleri temsil etmektedir.
```{r}
plotMA(res, alpha=0.05)
```


### 3) ggplot ile MA Grafiği
Bu görselleştirme de ggplot paketini kullanarak bir MA grafiği çizdirelim. Bunun için öncelikle anlamlı olan genleri belirtmek için yeni bir sütün oluşturulalım. Bunu `ifelse()` fonksiyonu ile yapabiliriz. 

```{r}
res$signaficant <- ifelse(res$pvalue <= 0.05, "yes", "no")
head(res)
```

Bu işlemden sonra ggplot ile görselleştirme yapabiliriz.

```{r}
res %>% ggplot(aes(x=log(baseMean), y=log2FoldChange, color= signaficant)) +
  geom_point()
```


### 5)ggplot ile Volcano Grafiği

Volcano grafiği, MA grafiğine benzer şekilde diferensiyal olarak ifade edilen genlerin yorumlanmasında kullanılır.

```{r}
res %>% ggplot(aes(x=log2FoldChange, y=-log10(pvalue), color= signaficant)) +
  geom_point()
```

### 6)Enhanced Volcano Plot

Enhanced Volcano ile kolayca volcano plot çizdirelim.

```{r}
EnhancedVolcano(res_deseq, x="log2FoldChange", y="padj", lab = rownames(res_deseq))
```


### 7)pheatmap

Şimdi diferensiyal olarak önemli olan genler ile heatmap grafiği çizdirelim. Bunun için öncelikle res objemizden yalnızca anlamlı yani p-value değeri 0.05 ve 0.05'den küçük genleri seçmeliyiz. Bu işlem için `subset()` fonksiyonunu kullanabiliriz.

```{r}
significant <- subset(res_deseq, subset=res$pvalue <= 0.05)
head(significant)
```
İkinci işlem olarak normalize edilmiş sayımlar ile diferensiyal olarak anlamlı genleri tek bir veri altında toplamamız gerekir.Bunun için iki veri yapısını birleştirmek için `merge()` fonksiyonu kullanılır.

```{r}
all_sig <- merge(normalized_counts, significant, by=0)
head(all_sig)
```
Hazırlanan all_sig verisinden sayımlar tekrar çekilir. Bunun için indekleme kullanılır.


```{r}
counts_sig_n <- all_sig[,2:5]
head(counts_sig_n)
```

count_sig_n verisine row names eklemek için `row.names()` fonksiyonu kullanılır.


```{r}
row.names(counts_sig_n) <- all_sig$Row.names

head(counts_sig_n)
```

Artık heatmap oluşturmak için verimiz hazır. Heatmap çizdirmek için `pheatmap()` fonksiyonu kullanılır.

```{r}
pheatmap(counts_sig_n)
```

Çıkan görsel göze hoş gelmediği için sayımlar log formuna çevrilir. Aynı zamanda `scale` parametresini kullanarak sütün veya sıraya göre ifade seviyesini karşılaştırmasını isteyebiliriz. `show_rownames` parametresini `FALSE` yaparak gen isimlerini kaldırabiliriz. 



```{r}
pheatmap(log2(counts_sig_n + 1), scale = "row", show_rownames = F)
```

Son olarak, istenildiği taktirde `treeheight_row` ve `treeheight_col` parametrelerini kullanarak ağaçları kaldırabiliriz.


```{r}
pheatmap(log2(counts_sig_n + 1), 
         scale = "row", 
         show_rownames = F, 
         treeheight_row = 0,
         treeheight_col = 0)
```

### 6)pheatmap ile TOP20 genin heatmap grafiği

Top 20 gen, pvalue değerlerine göre yapılan sıralama sonucunda seçilir. Daha sonra 20 genin sayım matrisleri seçilir ve row.names eşleşmesi gerçekleştirilir.

```{r}
top20 <- head(all_sig[order(all_sig$pvalue),],20)
top20_counts <- top20[ ,2:5]
row.names(top20_counts) <- top20$Row.names
head(top20_counts)


```

Son olarak, top 20 genin heatmap grafiğini görmek için `pheatmap()` fonksiyonu kullanılır.

```{r}
pheatmap(log2(top20_counts + 1))
```








